#version 450

#include "gaussian_splatting_types.glsl"

#extension GL_EXT_debug_printf : enable


layout(local_size_x = 256) in;

#extension GL_EXT_scalar_block_layout : enable

layout(scalar, binding = 0) buffer InputBuffer {
    Gaussian2D gaussians[];
} inputBuffer;

layout(scalar, binding = 2) buffer OutputBuffer {
    Gaussian2D gaussians[];
} outputBuffer;

layout(scalar, binding = 3) buffer CountBuffer {
    uint counts[];
} countBuffer;

layout(scalar, binding = 4) buffer OffsetBuffer {
    uint offsets[];
} offsetBuffer;

layout(scalar, binding = 5) buffer InputBuffer2 {
    uint numberTotalGaussians;
} inputBuffer2;

layout(push_constant) uniform PushConstants {
    uint pass;
    uint numElements;
    uint numBins;

} pushConstants;

bool debug = true;

// Helper function to get the bin at a specific position
// this uses 16 bins (= 4 bits of the float value for each pass)
uint getBin(uint value, uint binMask, uint pass) {
    // Invert the sign bit for correct float sorting
    value ^= 0x80000000u;

    // depending on the pass, we need to switch between the depth value and the binMask
    uint switched = pass >= (32/4) ? binMask : value;
    // for pass >= 32, we would need to either subtract 32 or
    // use the modulo operator
    pass = pass % (32/4);
    // shift the value to the right by 4 * pass bits
    // and mask it to get the last 4 bits
    return (switched >> (pass * 4)) & 0xF;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= inputBuffer2.numberTotalGaussians) return;

    if (idx == 0) {
        if (debug) {
            debugPrintfEXT("Radix sort pass: %u\n", pushConstants.pass);
            debugPrintfEXT("Initial Number of elements: %u\n", pushConstants.numElements);
            debugPrintfEXT("Number of elements: %u\n", inputBuffer2.numberTotalGaussians);
        }
    }

    // get the value to sort (use z here)
    uint value = floatBitsToUint(inputBuffer.gaussians[idx].z);
    uint binMask = inputBuffer.gaussians[idx].binMask;
    
    // get the bin of the current value for the current pass
    uint bin = getBin(value, binMask, pushConstants.pass);

    // count the occurrences of this bin
    atomicAdd(countBuffer.counts[bin], 1);

}