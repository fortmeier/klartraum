#version 450

#include "gaussian_splatting_types.glsl"

layout(local_size_x = 128) in;

#extension GL_EXT_scalar_block_layout : enable
// #extension GL_EXT_debug_printf : enable

layout(scalar, binding = 0) buffer InputBuffer {
    Gaussian2D gaussians[];
} inputBuffer;

layout(scalar, binding = 1) buffer OutputBuffer {
    uint numberAdditionalGaussians;
} outputBuffer;


layout(push_constant) uniform PushConstants {
    uint numElements;
    uint gridSize;
    float screenWidth;
    float screenHeight;
} pushConstants;

// Helper function to get the bin index for a position
uint getBinIndex(vec2 position) {
    // Calculate grid cell size
    float cellWidth = pushConstants.screenWidth / float(pushConstants.gridSize);
    float cellHeight = pushConstants.screenHeight / float(pushConstants.gridSize);
    
    // Calculate grid coordinates
    uint gridX = uint(position.x / cellWidth);
    uint gridY = uint(position.y / cellHeight);
    
    // Clamp to grid bounds
    gridX = min(gridX, pushConstants.gridSize - 1);
    gridY = min(gridY, pushConstants.gridSize - 1);
    
    // Convert 2D grid coordinates to 1D bin index
    return gridY * pushConstants.gridSize + gridX;
}

// Helper function to check if a gaussian overlaps with a bin
bool overlapsWithBin(Gaussian2D gaussian, uint binIndex) {
    // Calculate grid cell size
    float cellWidth = pushConstants.screenWidth / float(pushConstants.gridSize);
    float cellHeight = pushConstants.screenHeight / float(pushConstants.gridSize);
    
    // Calculate bin bounds
    uint gridX = binIndex % pushConstants.gridSize;
    uint gridY = binIndex / pushConstants.gridSize;
    
    vec2 binMin = vec2(gridX * cellWidth, gridY * cellHeight);
    vec2 binMax = vec2((gridX + 1) * cellWidth, (gridY + 1) * cellHeight);
    
    // Calculate gaussian bounds using covariance matrix
    // For simplicity, we'll use the diagonal elements of the covariance matrix
    // as a measure of the gaussian's spread
    float spreadX = sqrt(gaussian.covariance[0][0]);
    float spreadY = sqrt(gaussian.covariance[1][1]);
    
    vec2 gaussianMin = gaussian.position - vec2(spreadX, spreadY);
    vec2 gaussianMax = gaussian.position + vec2(spreadX, spreadY);

    // Check for overlap
    return !(gaussianMax.x < binMin.x || gaussianMin.x > binMax.x ||
             gaussianMax.y < binMin.y || gaussianMin.y > binMax.y);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint numberGridElements = pushConstants.gridSize * pushConstants.gridSize;

    if (idx == 0) {
        // Initialize the number of additional gaussians to zero
        outputBuffer.numberAdditionalGaussians = 0;
    }

    //return;
    if (idx >= pushConstants.numElements) return;

    barrier();

    // Get the gaussian
    Gaussian2D gaussian = inputBuffer.gaussians[idx];
    
    uint numberOverlappingBins = 0;
    // Find all bins this gaussian overlaps with
    // and for the first overlapping bin, set the binMask of the gaussian
    // for all other overlapping bins, create a new gaussian and put it at
    // the end of the list
    for (uint binIndex = 0; binIndex < numberGridElements; binIndex++) {
        if (overlapsWithBin(gaussian, binIndex)) {
            // Increment count for this bin
            numberOverlappingBins++;
            if (numberOverlappingBins > 1) {
                
                uint newGaussianIndex = pushConstants.numElements + atomicAdd(outputBuffer.numberAdditionalGaussians, 1);

                if(newGaussianIndex < pushConstants.numElements * 2) {
                    // Create a new gaussian for this bin
                    Gaussian2D newGaussian = gaussian;
                    newGaussian.binMask = 1 << binIndex; // Set the binMask to the current bin
                    inputBuffer.gaussians[newGaussianIndex] = newGaussian;

                    // Debug print: new gaussian created
                    // debugPrintfEXT("New Gaussian[%u / %u]: pos=(%f,%f), cov=(%f,%f,%f,%f), binMask=0x%x\n",
                    //     newGaussianIndex,
                    //     pushConstants.numElements * 2,
                    //     newGaussian.position.x, newGaussian.position.y,
                    //     newGaussian.covariance[0][0], newGaussian.covariance[0][1],
                    //     newGaussian.covariance[1][0], newGaussian.covariance[1][1],
                    //     newGaussian.binMask
                    // );

                } else {
                    // Error: too many additional gaussians
                    // debugPrintfEXT("Error: Too many additional gaussians created! Index: %u\n", newGaussianIndex);
                }


            } else {
                inputBuffer.gaussians[idx].binMask = 1 << binIndex;
            }
            
        }
    }

    barrier();

    if (idx == 0) {
        // Initialize the number of additional gaussians to zero
        outputBuffer.numberAdditionalGaussians = min(outputBuffer.numberAdditionalGaussians, pushConstants.numElements);
        debugPrintfEXT("Total number of additional gaussians: %u\n", outputBuffer.numberAdditionalGaussians);
    }
} 