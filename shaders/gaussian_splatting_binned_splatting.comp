#version 450

#include "gaussian_splatting_types.glsl"

layout(local_size_x = 16, local_size_y = 16) in;


#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable

// Original Gaussian2D data
layout(scalar, binding = 0) buffer GaussianBuffer {
    Gaussian2D gaussians[];
} gaussianBuffer;

layout(scalar, binding = 1) buffer InputBuffer2 {
    uint numberTotalGaussians;
} inputBuffer2;

layout(scalar, binding = 2) buffer OutputBuffer {
    StartAndEnd startAndEnd[];
} inputBuffer3;


// Output image
layout(binding = 3, rgba8) uniform image2D outputImage;

layout(push_constant) uniform PushConstants {
    uint numElements;
    uint gridSize;
    uint binIndexX;
    uint binIndexY;
    float screenWidth;
    float screenHeight;
} pushConstants;

float evaluateGaussian(vec2 x, vec2 mu, mat2 sigma) {
    vec2 diff = (x - mu);
    mat2 sigmaInv = inverse(sigma);
    float distance = dot(diff, (sigmaInv * diff));
    return exp(-0.5 * distance);
}

bool debug = false;

void main() {


    ivec2 binOffset;
    binOffset.x = int(pushConstants.binIndexX * gl_WorkGroupSize.x * gl_NumWorkGroups.x);
    binOffset.y = int(pushConstants.binIndexY * gl_WorkGroupSize.y * gl_NumWorkGroups.y);

    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy) + binOffset;
    if (pixelCoord.x >= int(pushConstants.screenWidth) || 
        pixelCoord.y >= int(pushConstants.screenHeight)) {
        return;
    }


    uint start = inputBuffer3.startAndEnd[pushConstants.binIndexY * pushConstants.gridSize + pushConstants.binIndexX].start;
    uint end = inputBuffer3.startAndEnd[pushConstants.binIndexY * pushConstants.gridSize + pushConstants.binIndexX].end;

    float bufferFullWarning = inputBuffer2.numberTotalGaussians >= pushConstants.numElements * 2 ? 1.0 : 0.0;
    vec4 backgroundColor = vec4(
        pushConstants.binIndexX / float(pushConstants.gridSize),
        pushConstants.binIndexY / float(pushConstants.gridSize), 
        bufferFullWarning, 0.5);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);


    
    // Accumulate contributions from all Gaussians in this bin
    float accum_opacity = 1.0;

    for (uint i = start; i < end; i++) {
        Gaussian2D gaussian = gaussianBuffer.gaussians[i];
        
        // Evaluate Gaussian at this pixel
        float a_i = evaluateGaussian(pixelCoord, gaussian.position, gaussian.covariance) * gaussian.alpha;

        // += c_i * a_i * opacity     
        finalColor += vec4(gaussian.color * a_i * accum_opacity, 0);
        accum_opacity *= (1.0 - a_i);

        if (accum_opacity <= 1.0 - 0.9999) {
            break; // Early exit if opacity is very low
        }
    }


    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
        if (debug) {
            debugPrintfEXT("pixelCoord: (%d, %d)\n", pixelCoord.x, pixelCoord.y);
            debugPrintfEXT("start: %u, end: %u\n", start, end);
            debugPrintfEXT("Total number of gaussians: %u\n", inputBuffer2.numberTotalGaussians);
        }
        for (uint i = start; i < end; i++) {
            Gaussian2D gaussian = gaussianBuffer.gaussians[i];
            if (debug) {
                debugPrintfEXT("gaussian[%u]: pos=(%f, %f), cov=(%f, %f, %f, %f), pixelCoord=(%d, %d)\n", 
                    i, gaussian.position.x, gaussian.position.y, 
                    gaussian.covariance[0][0], gaussian.covariance[0][1], 
                    gaussian.covariance[1][0], gaussian.covariance[1][1],
                    pixelCoord.x, pixelCoord.y);
            }
        }
        if (debug) {
            debugPrintfEXT("finalColor: (%f, %f, %f, %f), bin: (%u, %u), start: %u, end: %u\n",
                finalColor.r, finalColor.g, finalColor.b, finalColor.a, pushConstants.binIndexX, pushConstants.binIndexY, start, end);
        }
    }

    vec4 imageInput = imageLoad(outputImage, pixelCoord);
    vec4 outputColor = imageInput + backgroundColor * backgroundColor.w * float(debug) + finalColor * (1.0 - accum_opacity);
    outputColor = clamp(outputColor, vec4(0.0), vec4(1.0));

    //debugPrintfEXT("pixelCoord: (%d, %d), finalColor: (%f, %f, %f, %f)\n", pixelCoord.x, pixelCoord.y, finalColor.r, finalColor.g, finalColor.b, finalColor.a);
    // Write final color to output image
    imageStore(outputImage, pixelCoord, outputColor);
} 