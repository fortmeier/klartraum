#version 450

#include "gaussian_splatting_types.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

#extension GL_EXT_scalar_block_layout : enable

layout(scalar, set = 0, binding = 0) readonly buffer GaussiansSSBOIn {
   Gaussian gaussianIn[ ];
};


layout(set = 0, binding = 1) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout (scalar, set = 0, binding = 2) buffer outputGaussians {
    Gaussian2D gaussian2dOut[ ];
};


layout(push_constant) uniform PushConstants {
    uint numElements;
    uint gridSize;
    float screenWidth;
    float screenHeight;
} pushConstants;

#extension GL_EXT_debug_printf : enable

bool debug = false;

// DANGER: AI GENERATED CODE
mat3 quatToMat3(vec4 q) {
    float x = q.x, y = q.y, z = q.z, w = q.w;
    float xx = x * x, yy = y * y, zz = z * z;
    float xy = x * y, xz = x * z, yz = y * z;
    float wx = w * x, wy = w * y, wz = w * z;

    mat3 r = mat3(
        1.0 - 2.0 * (yy + zz),  2.0 * (xy - wz),        2.0 * (xz + wy),
        2.0 * (xy + wz),        1.0 - 2.0 * (xx + zz),  2.0 * (yz - wx),
        2.0 * (xz - wy),        2.0 * (yz + wx),        1.0 - 2.0 * (xx + yy)
    );

    return r;
    
}

mat2 calculateCovarianceMatrix2D(Gaussian gaussian, vec3 u) {
    mat3 S = mat3(
        gaussian.scale.x, 0.0, 0.0,
        0.0, gaussian.scale.y, 0.0,
        0.0, 0.0, gaussian.scale.z
    );

    mat3 R = quatToMat3(gaussian.rotation);
    
    mat3 cov3dInObjectSpace = R * S * transpose(S) * transpose(R);

    mat4 W4 = ubo.model * ubo.view;
    mat3 W = mat3(
        W4[0][0], W4[0][1], W4[0][2],
        W4[1][0], W4[1][1], W4[1][2],
        W4[2][0], W4[2][1], W4[2][2]
    );


    float u0 = u[0];
    float u1 = u[1];
    float u2 = u[2];

    float l = length(u);

    mat3 J = mat3(
        1.0 / u2, 0.0, -u0 / (u2 * u2),
        0.0, 1.0 / u2, -u1 / (u2 * u2),
        u0 / l, u1 / l, u2 / l);

    mat3 cov3dInCameraSpace = J * W * cov3dInObjectSpace * transpose(W) * transpose(J); 

    mat2 cov2d = mat2(
        cov3dInCameraSpace[0][0], cov3dInCameraSpace[0][1],
        cov3dInCameraSpace[1][0], cov3dInCameraSpace[1][1]
    );

    return cov2d;
}

    

void main()
{
    uint index = gl_GlobalInvocationID.x;

    if (index >= pushConstants.numElements) {
        return; // Out of bounds
    }
    
    vec3 p = gaussianIn[index].position;

    vec4 position = ubo.proj * ubo.view * ubo.model * vec4(p, 1.0);

    if(debug && index == 0) {
        debugPrintfEXT("ubo.proj:\n[%f %f %f %f]\n[%f %f %f %f]\n[%f %f %f %f]\n[%f %f %f %f]\n",
            ubo.proj[0][0], ubo.proj[0][1], ubo.proj[0][2], ubo.proj[0][3],
            ubo.proj[1][0], ubo.proj[1][1], ubo.proj[1][2], ubo.proj[1][3],
            ubo.proj[2][0], ubo.proj[2][1], ubo.proj[2][2], ubo.proj[2][3],
            ubo.proj[3][0], ubo.proj[3][1], ubo.proj[3][2], ubo.proj[3][3]
        );

        debugPrintfEXT("ubo.view:\n[%f %f %f %f]\n[%f %f %f %f]\n[%f %f %f %f]\n[%f %f %f %f]\n",
            ubo.view[0][0], ubo.view[0][1], ubo.view[0][2], ubo.view[0][3],
            ubo.view[1][0], ubo.view[1][1], ubo.view[1][2], ubo.view[1][3],
            ubo.view[2][0], ubo.view[2][1], ubo.view[2][2], ubo.view[2][3],
            ubo.view[3][0], ubo.view[3][1], ubo.view[3][2], ubo.view[3][3]
        );

        debugPrintfEXT("ubo.model:\n[%f %f %f %f]\n[%f %f %f %f]\n[%f %f %f %f]\n[%f %f %f %f]\n",
            ubo.model[0][0], ubo.model[0][1], ubo.model[0][2], ubo.model[0][3],
            ubo.model[1][0], ubo.model[1][1], ubo.model[1][2], ubo.model[1][3],
            ubo.model[2][0], ubo.model[2][1], ubo.model[2][2], ubo.model[2][3],
            ubo.model[3][0], ubo.model[3][1], ubo.model[3][2], ubo.model[3][3]
        );
    }

    vec2 norm_pos = position.xy / position.w;
    vec3 u = position.xyz / position.w;
    Gaussian2D gaussian2d;

    gaussian2d.position = vec2((norm_pos.x+1.0)*256.0, (norm_pos.y+1.0)*256.0);
    gaussian2d.z = position.z;

    mat2 covariance = calculateCovarianceMatrix2D(gaussianIn[index], u);
    covariance /= position.w;

    // it is not mentioned in the original Gaussian Splatting paper, 
    // but they add a small value to the diagonal of the covariance matrix
    // so that each gaussian is at least a pixel wide
    // https://github.com/graphdeco-inria/diff-gaussian-rasterization/blob/59f5f77e3ddbac3ed9db93ec2cfe99ed6c5d121d/cuda_rasterizer/forward.cu#L109
    covariance[0][0] += 0.3;
    covariance[1][1] += 0.3;

    gaussian2d.covarianceInv = inverse(covariance);

    gaussian2d.color = gaussianIn[index].color;
    gaussian2d.alpha = gaussianIn[index].alpha;

    gaussian2d.binMask = uint(-1); // set to a dummy value for now, should be set based on the binning logic in the next step

    // BINNING CODE MUST BE MOVED HERE FOR OPTIMAL PERFORMANCE
    gaussian2dOut[index] = gaussian2d;

    if (debug) {
       debugPrintfEXT("Index: %u, Position.z: %f\n", index, position.z);
    }

}