#version 450

layout(local_size_x = 256) in;

#include "gaussian_splatting_types.glsl"

#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable

layout(scalar, binding = 0) buffer InputBuffer {
    Gaussian2D gaussians[];
} inputBuffer;

layout(scalar, binding = 1) buffer InputBuffer2 {
    uint numberAdditionalGaussians;
} inputBuffer2;

layout(scalar, binding = 2) buffer OutputBuffer {
    StartAndEnd startAndEnd[];
} outputBuffer;


layout(push_constant) uniform PushConstants {
    uint numElements;
    uint gridSize;
} pushConstants;


void main() {
    uint idx = gl_GlobalInvocationID.x;


    uint numGridElements = pushConstants.gridSize * pushConstants.gridSize;

    // initialize the start and end indices of the grid element sequences
    // to zero -> if start and end the same, the sequence for this bin is empty
    if (idx == 0) {
        for (uint i = 0; i < numGridElements; i++) {
            outputBuffer.startAndEnd[i].start = 0;
            outputBuffer.startAndEnd[i].end = 0;
        }
    }

    barrier();


    // discard all threads that are not in the range of the input buffer
    if (idx >= pushConstants.numElements + inputBuffer2.numberAdditionalGaussians) return;


    if (idx == pushConstants.numElements + inputBuffer2.numberAdditionalGaussians - 1) {
        // last element: store the end index of the whole sequence
        uint binMask = inputBuffer.gaussians[idx].binMask;
        uint logBinMask = uint(log2(binMask));
        outputBuffer.startAndEnd[logBinMask].end = idx + 1;
        return;
    } else {
        // all other elements: store the start and end indices
        // of the current and next element if they are different
        // i.e. if there is a boundary between two elements
        uint binMask = inputBuffer.gaussians[idx].binMask;
        uint binMaskNext = inputBuffer.gaussians[idx+1].binMask;

        uint logBinMask = uint(log2(binMask));
        uint logBinMaskNext = uint(log2(binMaskNext));

        // debugPrintfEXT("Bounds idx: %u m0: %u m1: %u logm0: %u logm1: %u\n", idx, binMask, binMaskNext, logBinMask, logBinMaskNext);

        if (binMask != binMaskNext) {
            outputBuffer.startAndEnd[logBinMask].end = idx + 1;
            outputBuffer.startAndEnd[logBinMaskNext].start = idx + 1;
        }
    }

} 