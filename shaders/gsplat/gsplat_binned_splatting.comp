#version 450

#include "gsplat_types.glsl"

layout(local_size_x = 8, local_size_y = 8) in;


#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable

// Original Gaussian2D data
layout(scalar, binding = 0) buffer GaussianBuffer {
    Gaussian2D gaussians[];
} gaussianBuffer;

layout(scalar, binding = 1) buffer InputBuffer2 {
    uint numberTotalGaussians;
} inputBuffer2;

layout(scalar, binding = 2) buffer OutputBuffer {
    StartAndEnd startAndEnd[];
} inputBuffer3;

shared Gaussian2D sharedGaussians[8*8]; // Shared memory for gaussians in the workgroup

// Output image
layout(binding = 3, rgba8) uniform image2D outputImage;

layout(push_constant) uniform PushConstants {
    uint numElements;
    uint gridSize;
    uint binIndexX;
    uint binIndexY;
    float screenWidth;
    float screenHeight;
} pushConstants;

float evaluateGaussian(vec2 x, vec2 mu, mat2 sigmaInv) {
    vec2 diff = (x - mu);
    float distance = dot(diff, (sigmaInv * diff));
    return exp(-0.5 * distance);
}

bool debug = false;

void main() {


    ivec2 binOffset;
    binOffset.x = int(pushConstants.binIndexX * gl_WorkGroupSize.x * gl_NumWorkGroups.x);
    binOffset.y = int(pushConstants.binIndexY * gl_WorkGroupSize.y * gl_NumWorkGroups.y);

    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy) + binOffset;
    if (pixelCoord.x >= int(pushConstants.screenWidth) || 
        pixelCoord.y >= int(pushConstants.screenHeight)) {
        return;
    }


    const StartAndEnd range = inputBuffer3.startAndEnd[pushConstants.binIndexY * pushConstants.gridSize + pushConstants.binIndexX];
    const uint start = range.start;
    const uint end = range.end;

    const uint stepsize = gl_WorkGroupSize.x * gl_WorkGroupSize.y;

    const uint preend = end - end % stepsize;

    float bufferFullWarning = inputBuffer2.numberTotalGaussians >= pushConstants.numElements * 2 ? 1.0 : 0.0;
    vec4 backgroundColor = vec4(
        pushConstants.binIndexX / float(pushConstants.gridSize),
        pushConstants.binIndexY / float(pushConstants.gridSize), 
        bufferFullWarning, 0.5);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);


    
    // Accumulate contributions from all Gaussians in this bin
    float accum_opacity = 1.0;

    for (uint i = start; i < preend; i+= stepsize) {
        // Load Gaussian from shared memory if available
        sharedGaussians[gl_LocalInvocationIndex] = gaussianBuffer.gaussians[i + gl_LocalInvocationIndex];

        // Wait for all threads in the workgroup to load their Gaussians
        barrier();

        // Process the Gaussians in shared memory
        for (uint j = 0; j < stepsize; j++) {
            Gaussian2D gaussian = sharedGaussians[j];

            // Evaluate Gaussian at this pixel
            float a_j = evaluateGaussian(pixelCoord, gaussian.position, gaussian.covarianceInv) * gaussian.alpha;

            // += c_i * a_i * opacity     
            finalColor += vec4(gaussian.color * a_j * accum_opacity, 0);
            accum_opacity *= (1.0 - a_j);
        }

        if (accum_opacity <= 1.0 - 0.9999) {
            break; // Early exit if opacity is very low
        }
    }

    for (uint i = preend; i < end; i++) {
        Gaussian2D gaussian = gaussianBuffer.gaussians[i];
        
        // Evaluate Gaussian at this pixel
        float a_i = evaluateGaussian(pixelCoord, gaussian.position, gaussian.covarianceInv) * gaussian.alpha;

        // += c_i * a_i * opacity     
        finalColor += vec4(gaussian.color * a_i * accum_opacity, 0);
        accum_opacity *= (1.0 - a_i);

        if (accum_opacity <= 1.0 - 0.9999) {
            break; // Early exit if opacity is very low
        }
    }

    vec4 imageInput = imageLoad(outputImage, pixelCoord);
    vec4 outputColor = imageInput + backgroundColor * backgroundColor.w * float(debug) + finalColor * (1.0 - accum_opacity);
    outputColor = clamp(outputColor, vec4(0.0), vec4(1.0));

    // Write final color to output image
    imageStore(outputImage, pixelCoord, outputColor);
} 