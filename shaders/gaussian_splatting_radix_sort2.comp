#version 450

#include "gaussian_splatting_radix_sort_include.glsl"

layout(local_size_x = 128) in;

shared uint localBinCount;

shared bool isInBin[128];


void main() {
    uint bin = gl_WorkGroupID.x;
    if (bin >= 16) return;

    if (debug) {
        debugPrintfEXT("Processing bin %u\n", bin);
    }

    barrier();

    // radix sort requires that the order of the elements in each bin is preserved
    // so in each workgroup we will process one bin at a time
    // in each workgroup, all threads will fetch elements from the input buffer,
    // determine their bin and store them in local memory
    // then the first thread will increase the global bin counter
    // and all threads togther will copy the local memory to the output buffer


    for(uint step_idx = 0 ; step_idx < inputBuffer2.numberTotalGaussians / gl_WorkGroupSize.x + 1; step_idx += 1) {
        // for each workgroup
        if (gl_LocalInvocationID.x == 0) {
            localBinCount = 0;
        }
        barrier();
 
        uint idx = step_idx * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        //debugPrintfEXT("Processing bin %u in idx %u\n", bin, idx);
        if (idx >= inputBuffer2.numberTotalGaussians) {
            // if the index is out of bounds, we can skip this iteration
            isInBin[gl_LocalInvocationID.x] = false; // mark as invalid
            continue;
        }

        if (debug) {
            debugPrintfEXT("Processing bin %u in idx %u\n", bin, idx);
        }

        Gaussian2D gaussian = getInputGaussian(idx);
        // get the value to sort (use z here)
        uint value = floatBitsToUint(gaussian.z);
        uint binMask = gaussian.binMask;

        // get the bin of the current value for the current pass
        uint element_bin = getBin(value, binMask, pushConstants.pass);

        // if the bin of the gaussian is the one we are processing in this workgroup,
        // we flag it as being in the bin and increase the local bin count
        // otherwise we can skip this element
        if (element_bin == bin) {
            isInBin[gl_LocalInvocationID.x] = true;
            atomicAdd(localBinCount, 1);
        } else {
            isInBin[gl_LocalInvocationID.x] = false;
        }

        barrier();

        // finally, a single thread will copy the flagged elements to the output buffer
        if (gl_LocalInvocationID.x == 0) {

            // first, "reserve" space in the output buffer for this step
            uint localCopyStart = offsetBuffer.offsets[bin] + atomicAdd(countBuffer.counts[bin], localBinCount);

            // then copy
            uint currentOutputIdx = 0;
            for (uint i = 0; i < 128; i++) {
                if (isInBin[i]) {
                    uint outputPos = localCopyStart + currentOutputIdx;
                    uint inputPos = step_idx * gl_WorkGroupSize.x + i;
                    setOutputGaussian(outputPos, getInputGaussian(inputPos));
                    if (debug) {
                        debugPrintfEXT("bin %u: outputPos %u, offset %u\n", bin, outputPos, inputPos);
                    }
                    currentOutputIdx++;
                }
            }
        }
    }
}